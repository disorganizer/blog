<!DOCTYPE html>
<html lang="en-us">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Don&#39;t panic">

<base href="https://disorganizer.github.io/blog">
<title>


     The write layer 

</title>
<link rel="canonical" href="https://disorganizer.github.io/blog/post/the_write_layer/">


<script type="text/javascript">
    var baseURL = 'https:\/\/disorganizer.github.io\/blog';
    var host = baseURL.substring(0, baseURL.length - 1).replace(/\//g, '');
    if ((host === window.location.host) && (window.location.protocol !== 'https:')) {
        window.location.protocol = 'https:';
    }
</script>





<link rel="stylesheet" href="https://disorganizer.github.io/blog/css/reset.css">
<link rel="stylesheet" href="https://disorganizer.github.io/blog/css/pygments.css">
<link rel="stylesheet" href="https://disorganizer.github.io/blog/css/main.css">






<link rel="shortcut icon"

    href="https://disorganizer.github.io/blog/img/favicon.ico"

>



</head>


<body lang="en">

<section class="header"> 
    <div class="container">
        <div class="content">
            <a href="https://disorganizer.github.io/blog/"><div class="name">Chris Pahl</div></a>
            <nav>
                <ul>
                    <a href="https://disorganizer.github.io/blog/blog/"><li>Blog</li></a>
                    <a href="https://disorganizer.github.io/blog/about/"><li>About</li></a>
                    <a href="https://disorganizer.github.io/blog/code/"><li>Code</li></a>
                </ul>
            </nav>
        </div>
    </div>
</section>

<section class="icons">
    <div class="container">
        <div class="content">

        
            <a href="//github.com/sahib" target="_blank">
                <i class="icon ion-social-github"></i>
            </a>
        
        
        

        

        

        

        
            <a href="mailto:sahib@online.de">
                <i class="icon ion-ios-email larger"></i>
            </a>
        
        </div>
    </div>
</section>

<section class="main">
    <div class="container">
        <div class="content">
            <p>A bit more than a week since the last post, I&rsquo;m getting worse again. Screw it.
Besides a lot of personal life stuff a major &ldquo;problem&rdquo; was solved: Writing to
files. Doesn&rsquo;t sound like an impressive problem, I know.</p>

<p>But how is <code>brig</code> able to modify existing files by writing somewhere in them,
extending them or truncating them to some size? With the cli interface it&rsquo;s not
much of a problem, a simple <code>brig add</code> updates the file:</p>

<div class="highlight" style="background: #272822"><pre style="line-height: 125%"><span></span>$ <span style="color: #f8f8f2">echo</span> -n <span style="color: #e6db74">&#39;What now?&#39;</span> &gt; file.txt 
$ brig add file.txt <span style="color: #f92672">&amp;&amp;</span> brig cat file.txt
What now?
$ <span style="color: #f8f8f2">echo</span> <span style="color: #e6db74">&#39; PARTY!&#39;</span> &gt;&gt; file.txt
$ brig add file.txt <span style="color: #f92672">&amp;&amp;</span> brig cat file.txt
What now? PARTY!
</pre></div>


<p>The file is simply hashed and encrypted as a whole and is added to <code>ipfs</code>.
A new entry in the version history will be created and the next <code>cat</code>
gives the newer version.  But what about editing large files in the fuse layer?
Do we need to add the whole file on every edit over and over again?
That would be hella inefficient.</p>

<p>The solution is kinda obvious, but the devil is in the details.
Every file handle that is opened from the outside via the fuse layer
internally opens a seekable read-only stream to the actual data in ipfs.
The decryption and retrieving from <code>ipfs</code> is transparently managed, so
to the caller side it simply looks like a stream of the originally added file.
When a user writes data to the file, the data will be cached in memory a layer
over the original file. Once the file handle is closed, the written data will
be layered over the original read-only stream and added to <code>ipfs</code>.
Since images are easier to grasp than text, here&rsquo;s an example overlay:</p>

<p><img src="https://disorganizer.github.io/blog/img/write_overlay.svg" alt="Overlay" width="800px"/></p>

<p>That&rsquo;s the current solution and it&rsquo;s already a lot better than just re-adding
the file over and over. However, on every close the whole file is added anyways,
which makes editing large files inefficient. This might be helped in the future
by rolling hashes and direct writing to the blocks in <code>ipfs</code>.
Another drawback is that every write is cached in memory, which can obviously
suck up your RAM in minutes. A viable solution would be to implement a &ldquo;scratchpad&rdquo;
on disk where encrypted chunks of data will be stored until the handle closes.</p>

<p>As mentioned, the actual details are hairy. Implementing seekable decryption,
overlaying <code>io.Writers</code> and similar stuff is a really great source for one-off
errors and other exotic bugs that are hard to find. To be more exact: there are
known bugs: Truncating to zero and then appending to the end (like <code>echo xyz &gt;&gt;
file.txt</code>) produces a file with content zeroed everything before the appended
data.</p>

<p>Speaking of bugs, there are plenty of todos until the next blog entry:</p>

<ul>
<li><strong>Make creating files in fuse possible:</strong> This does not work currently for
unknown reasons.</li>
<li><strong>Actually add old files to commit history:</strong> Old hashes are silently discarded
and not unpinned. This will lead to lot of undeleteable garbage files.</li>
<li>The encryption format needs a field to <strong>remember compression and a MAC</strong> to
protect against forgery of the header data.</li>
<li><strong>General code cleanup:</strong> This involves running linters, removing debug messages
and cleaning up old hacks.</li>
<li>There are no <strong>tests</strong> for the fuse layer, but some bash scripts. These need
to be converted to go.</li>
</ul>

<p><strong>Long term goals:</strong></p>

<p>Before diving much deeper in the frontend part of <code>brig</code> (<code>fuse</code>, cli, etc.)
it&rsquo;s probably a good idea to get on the <code>xmpp/bolt</code> side and see if we can
persuade <code>brig</code> to sync files over the net. Steep goals, but you can already
get the raw from <code>ipfs</code> from another computer!</p>

<p>The next blog post will give therefore an overview of the current architecture
and how the source is layout. Writing about that always help figuring out what
parts I screwed up. ðŸ˜ƒ</p>

        </div>
    </div>
</section>




</body>
</html>

