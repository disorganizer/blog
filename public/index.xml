<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>brig devlog</title>
    <link>https://disorganizer.github.io/blog/</link>
    <description>Recent content on brig devlog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 Jan 2016 18:44:51 +0100</lastBuildDate>
    <atom:link href="https://disorganizer.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Making it persistent</title>
      <link>https://disorganizer.github.io/blog/post/bolt_and_fingerprint/</link>
      <pubDate>Sat, 16 Jan 2016 18:44:51 +0100</pubDate>
      
      <guid>https://disorganizer.github.io/blog/post/bolt_and_fingerprint/</guid>
      <description>&lt;p&gt;A bit more than one day after the last post. Not too bad.
Basically, three smaller things happened since the last time.&lt;/p&gt;

&lt;p&gt;First, we now store files serialized as protobufs in the index persistently.
The index is just a BoltDB database file (which I can recommend, it&amp;rsquo;s nice).&lt;/p&gt;

&lt;p&gt;Secondly, the AES-key for each file is generated from the &lt;code&gt;sha512&lt;/code&gt; hash of the
first 8KB of a file. We don&amp;rsquo;t hash the full file for performance reasons, but
there is nothing stopping us from hashing the whole file, so we fully apply to
&lt;a href=&#34;https://en.wikipedia.org/wiki/Convergent_encryption&#34;&gt;Wikipedia&amp;rsquo;s definiton of convergent
encryption&lt;/a&gt;. The hash is
then processed by &lt;code&gt;scrypt&lt;/code&gt; with the filesize as salt. Currently, the key is
also stored in the index.&lt;/p&gt;

&lt;p&gt;Finally, the commandline interface was cleared up a bit.
We now use the &lt;code&gt;withXY&lt;/code&gt; pattern which are usually popular in tests.
Since we use &lt;code&gt;climax&lt;/code&gt; as commandline library, we need to pass a callback
handle for each subcommand we have (&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;cat&lt;/code&gt;, etc.).
Almost all of them have in common that they need to talk to the daemon
and need a certain number of arguments to work.&lt;/p&gt;

&lt;p&gt;It would be nice to write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	Handle: withArgCheck(needAtLeast(2), withDaemon(handleAdd)),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; which is nicely possible by writing a function that returns a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type CheckFunc func(ctx climax.Context) int

func withArgCheck(checker CheckFunc, handler climax.CmdHandler) climax.CmdHandler {
	return func(ctx climax.Context) int {
		if checker(ctx) != Success {
			return BadArgs
		}

		return handler(ctx)
	}
}

func needAtLeast(min int) CheckFunc {
	return func(ctx climax.Context) int {
		if len(ctx.Args) &amp;lt; min {
			log.Warningf(&amp;quot;Need at least %d arguments.&amp;quot;, min)
			return BadArgs
		}

		return Success
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh, as an extra: We&amp;rsquo;re on GitHub now:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/disorganizer&#34;&gt;https://github.com/disorganizer&lt;/a&gt; (source)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://disorganizer.github.io/blog/index.html&#34;&gt;https://disorganizer.github.io/blog/index.html&lt;/a&gt; (blog)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That&amp;rsquo;s it for now. The next days should bring some of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Make the index remember directories.&lt;/li&gt;
&lt;li&gt;Recursively add directories.&lt;/li&gt;
&lt;li&gt;A humble start on the FUSE layer.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>A small step for mankind, a big step for brig</title>
      <link>https://disorganizer.github.io/blog/post/first_steps/</link>
      <pubDate>Fri, 15 Jan 2016 01:13:07 -0700</pubDate>
      
      <guid>https://disorganizer.github.io/blog/post/first_steps/</guid>
      <description>&lt;p&gt;A small historic moment was achieved today: The very first file was added to
&lt;code&gt;brig&lt;/code&gt;. There was no way to get it out again, but hey - Progress comes in
steps. Luckily, just two hours later there was a &lt;code&gt;brig get&lt;/code&gt; command that
could retrieve the file again from &lt;code&gt;ipfs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is also my very first devlog entry, so&amp;hellip; Hi. I mainly write this to
remember what I did (and when) on the course of the project. Also it sometimes
is really useful to reflect on what kind of boolshit I wrote today. Ever
noticed that you get the best ideas doing arbitrary things like peeing? That&amp;rsquo;s
the same effect, I guess. If it&amp;rsquo;s fun to read for others&amp;hellip; that&amp;rsquo;s okay too.
I try to keep it updated after every more or less productive session.
That might mean daily, that might also mean once a week.&lt;/p&gt;

&lt;p&gt;So, back to the technical side of life. &lt;code&gt;brig add&lt;/code&gt; currently works a bit
confusing. It is supposed to read a regular file on the disk, compress and
encrypt it and add it to &lt;code&gt;ipfs&lt;/code&gt;. The encryption and compression layer uses
&lt;code&gt;io.Writer&lt;/code&gt; though, so we can&amp;rsquo;t just stack &lt;code&gt;io.Reader&lt;/code&gt; on top of each
other. Instead we need to use a nice little feature from the stdlib:
&lt;code&gt;io.Pipe()&lt;/code&gt;. This function returns a &lt;code&gt;io.Writer&lt;/code&gt; and a &lt;code&gt;io.Reader&lt;/code&gt;. Every
write on the writer produces a corresponding read on the reader - without internal
copying of the data. Yay. If you have a piece of API that needs a &lt;code&gt;io.Reader&lt;/code&gt;,
but you just have a &lt;code&gt;io.Writer&lt;/code&gt;, then &lt;code&gt;io.Pipe()&lt;/code&gt; should pop into your mind now.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how it looks in practice:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewFileReader(key []byte, r io.Reader) (io.Reader, error) {
	pr, pw := io.Pipe()

	// Setup the writer part:
	wEnc, err := encrypt.NewWriter(pw, key)
	if err != nil {
		return nil, err
	}

	wZip := compress.NewWriter(wEnc)

	// Suck the reader empty and move it to `wZip`.
	// Every write to wZip will be available as read in `pr`.
	go func() {
		defer func() {
			wEnc.Close()
			pw.Close()
		}()

		if _, err := io.Copy(wZip, r); err != nil {
			// TODO: Warn or pass to outside?
			log.Warningf(&amp;quot;add: copy: %v&amp;quot;, err)
		}
	}()

	return pr, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all for today! For tomorrow a cleanup session is planned and the piece
of code that derives the AES-Key from an unencrypted file.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>